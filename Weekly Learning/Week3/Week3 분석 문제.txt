Q1. 숙련 1강 ~ 숙련 3강
**분석 문제** : 분석한 내용을 직접 작성하고, 강의의 코드를 다시 한번 작성하며 복습해봅시다.

- 입문 주차와 비교해서 입력 받는 방식의 차이와 공통점을 비교해보세요.
- `CharacterManager`와 `Player`의 역할에 대해 고민해보세요.
- 핵심 로직을 분석해보세요 (`Move`, `CameraLook`, `IsGrounded`)
- `Move`와 `CameraLook` 함수를 각각 `FixedUpdate`, `LateUpdate`에서 호출하는 이유에 대해 생각해보세요.


Q1 - 1. 입문 주차와 비교해서 입력 받는 방식의 차이와 공통점을 비교해보세요.

A.
공통점 :  공통점이라고 하면 Input Action을 설정해줬다는 것과, Player Input 컴포넌트를 사용한다는 것

차이점 :  입문 주차에는 InputAction을 만들 때 Add Control Scheme부터 만들어서 마우스, 키보드 입력을 받도록 한다.
	또한 Action Type을 별로 신경쓰지 않고 간단한 버튼 형식으로만 만들었었다.
	그리고 Player Input 컴포넌트에서 Behavior를 send message를 사용했다.
	send message를 사용했기 때문에  Action 이름 앞에 On 이 붙은 메서드를 만들어 지정한 키를 누르면 메서드가 실행되도록 했다.

	숙련 주차에서는 Action Type을 변경하여 mouse의 delta값이나 value의 vector2값으로 상하좌우 값을 받도록 했고
	Player Input 컴포넌트에서 Behavior를 Invoke Unity Events를 사용하여 각 Action에 button 이벤트를 할당하듯이 메서드를 지정해줄 수 있도록 한다


- `CharacterManager`와 `Player`의 역할에 대해 고민해보세요.

`CharacterManager`는 Player를 관리해주는 클래스다. Player에게 무슨 일이 일어났을 때, 여러가지 필드 값들을 관리해주는 클래스,
생성부터 선택, 삭제 등등 캐릭터의 데이터를 관리해준다. 또한 다른 오브젝트와의 접근이나 연동을 제어할 수 있다.

'Player'는 플레이어가 가지는 값들, 필드 값이나 다른 상태를 나타내는 클래스 등 어떤 행동이 아닌 무엇인가를 나타내는 수치만을 가지고 있는것
예를 들면 능력치(hp, stamina, mp, 공격력 등)나 그 능력치가 담긴 상태창 같은것들을 포함한다. 




Q1 - 2. 핵심 로직을 분석해보세요 (`Move`, `CameraLook`, `IsGrounded`)

A.
`Move` 같은 경우는 InputAction을 통해 curMovementInput값을 받아 그 값으로 위치를 이동시킨다. 이 때 주의할 점은
curMovementInput는 Vector2 값이고 Move는 Vector3를 이용해 rigidbody.velocity를 변경시켜 움직이므로 방향을 잘 조절해줘야 하며,
이동할 때 y값을 고정시켜 캐릭터의 높이 위치가 바뀌지 않도록 조절해준다.

`CameraLook`의 경우는 마우스 위치를 받아와 x축, y축을 회전시켜 시야를 전환시킨다. 이 때 x축을 회전시켜야 상하로 시야를 회전하고 
y축을 회전시켜야 좌우로 시야가 회전되는데 유니티에선 x축을 회전시킬 때 -값이 되어야 위쪽으로 시야가 전환되기 때문에 마우스 delta값을 넣어줄 때
부호에 주의해야 한다. 또한 시야가 90도를 넘어가면 부자연스럽게 뒤집힐 수 있으니 clamp를 사용해 시야 전환에 범위를 제한한다.
또 한가지 주의할 점은 시야를 상하로 움직일 때 캐릭터 자체의 각도를 움직이는 것이 아닌 하위 오브젝트에 속한 카메라의 각도를 움직여줘야 한다.
world 앵글이 아닌, local 앵글을 움직여줘야 하는 것이다.
그와는 달리 시야를 좌우로 전환할 때는 캐릭터의 회전을 시켜주면 되니 그냥 world좌표로 회전을 시켜주면 된다.
이 때 만약 좌우 회전도 local좌표로 회전시켜 주고 싶으면 그렇게 해도 되는데 이 때는 바라보는 화면과 이동 방향이 달라질 수 있다. 
그리고 local 좌표, world 좌표 전부 회전시켜줄 방법이 필요해질 것 같다.

`IsGrounded는 캐릭터에서 지면으로 4개의 ray를 쏴서 하나라도 지면 오브젝트와 접촉 했을때를 감지하기 위해 만들어졌다.
처음부터 접촉해있으면 곤란하니 생성 위치를 조금 조절하여 살짝 공중에 떠 있도록 했다. 이 메서드를 통해 지면에 있을때만 점프가 가능하도록 만든다.




Q1 - 3. `Move`와 `CameraLook` 함수를 각각 `FixedUpdate`, `LateUpdate`에서 호출하는 이유에 대해 생각해보세요.

A.
'Move'와 같이 물리 연산을 해주는 것은 FixedUpdate에서 해주는 것이 좋다. 물리 연산은 바로바로 일어나야 하는데 FixedUpdate는 고정된 시간마다 Update를
진행하기 때문에 적합하다. Update와 LateUpdate는 프레임마다 호출되어 불규칙적이기 때문에 Move와 같은 물리 연산을 하는 함수를 호출하기엔 부적절하다

`CameraLook` 같은 경우 오브젝트의 변화에 맞춰 변화하기 때문에 오브젝트가 모두 변화한 이후에 Update 시켜주는게 좋기 때문에 Update 함수 호출 이후에
호출되는 LateUpdate에서 호출하는게 적합하다.

FixedUpdate()
프레임 기반으로 호출되는 Update와 달리 Fixed Timestep에 설정된 값에 따라 일정한 간격(Default : 0.02sec)으로 호출된다! 물리 효과가 적용된(Rigidbody) 오브젝트를 조정할 때 사용된다. Update는 불규칙한 호출임으로 물리충돌 검사로는 상대적으로 부적합하다.

Update()
스크립트가 활성화(enabled) 상태일 때, 매 프레임마다 호출된다! 주기가 일정하지 않아 물리효과가 적용되지 않은 오브젝트의 움직임이나 단순한 타이머, 키 입력을 받을 때 사용된다!

LateUpdate()
모든 Update 함수가 호출된 후, 마지막으로 호출된다. 주로 오브젝트를 따라가게 하는 카메라와 같은 곳에 자주 사용된다!





Q2. 숙련 4강 ~ 숙련 6강

**분석 문제** : 분석한 내용을 직접 작성하고, 강의의 코드를 다시 한번 작성하며 복습해봅시다.

- 별도의 UI 스크립트를 만드는 이유에 대해 객체지향적 관점에서 생각해보세요.
- 인터페이스의 특징에 대해 정리해보고 구현된 로직을 분석해보세요.
- 핵심 로직을 분석해보세요. (UI 스크립트 구조, `CampFire`, `DamageIndicator`)


Q2 - 1. 별도의 UI 스크립트를 만드는 이유에 대해 객체지향적 관점에서 생각해보세요.

A.
UI마다 고유의 역할이 존재한다. 하나의 클래스는 하나의 역할만을 수행해야 하기 때문에 UI마다 스크립트를 만들어준다.

Q2 - 2. 인터페이스의 특징에 대해 정리해보고 구현된 로직을 분석해보세요.

인터페이스에서 선언한 함수는 상속받은 클래스에서 무조건 정의가 되어야 한다. 
이러한 특징을 이용해 공통적인 메서드를 가진 클래스들을 선별해 인터페이스를 만들고 상속시키는 것, 그렇게 하면 활용하기도 좋고 수정이 조금만 필요해진다
지금 여기서 만든 인터페이스 메서드는 데미지를 받는 메서드인데 
실행되면 체력을 줄이고 Action 함수를 실행시킨다.

Q2 - 3. 핵심 로직을 분석해보세요. (UI 스크립트 구조, `CampFire`, `DamageIndicator`)

